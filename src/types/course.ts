import { z } from 'zod';
import { ProcessedParticipant, LessonData } from '../types';

/**
 * Person information for instructor and coordinator
 */
export interface PersonInfo {
  name: string;
  email: string;
  phone?: string;
}

/**
 * Course participant with enrollment order
 */
export interface CourseParticipant {
  id: string;
  name: string;
  email: string;
  enrollmentOrder: number;
  isActive: boolean;
}

/**
 * Session information for morning/afternoon
 */
export interface SessionInfo {
  startTime: string; // HH:MM format
  endTime: string;   // HH:MM format
  duration: number;  // minutes
}

/**
 * Lesson schedule for a specific date
 */
export interface LessonSchedule {
  date: string; // YYYY-MM-DD
  sessions: {
    morning?: SessionInfo;
    afternoon?: SessionInfo;
  };
  lessonType: 'online' | 'presence' | 'hybrid';
  subject?: string;
}

/**
 * Course settings and configurations
 */
export interface CourseSettings {
  minimumAttendancePercentage: number;
  allowManualAdjustments: boolean;
  autoGenerateDocuments: boolean;
  emailNotifications: boolean;
  backupFrequency: 'daily' | 'weekly' | 'manual';
}

/**
 * Course metadata
 */
export interface CourseMetadata {
  createdAt: string;
  updatedAt: string;
  version: string;
  totalLessons: number;
  completedLessons: number;
}

/**
 * Main course data structure
 */
export interface CourseData {
  courseId: string;
  courseInfo: {
    name: string;
    startDate: string;
    endDate: string;
    instructor: PersonInfo;
    coordinator: PersonInfo;
  };
  participants: CourseParticipant[];
  schedule: LessonSchedule[];
  settings: CourseSettings;
  metadata: CourseMetadata;
}

/**
 * Stored file in IndexedDB
 */
export interface StoredFile {
  filename: string;
  data: ArrayBuffer;
  uploadedAt: string;
  size: number;
}

/**
 * Manual adjustment for participant hours
 */
export interface ManualAdjustment {
  participantId: string;
  session: 'morning' | 'afternoon';
  originalHours: number;
  adjustedHours: number;
  reason: string;
  adjustedBy: string;
  adjustedAt: string;
}

/**
 * Generated documents for a lesson
 */
export interface GeneratedDocuments {
  moduloB?: {
    filename: string;
    data: ArrayBuffer;
    generatedAt: string;
  };
  absenceReport?: {
    filename: string;
    data: ArrayBuffer;
    generatedAt: string;
  };
}

/**
 * Processed lesson data for course context
 */
export interface ProcessedLessonData extends LessonData {
  courseId: string;
  dayNumber: number;
  isProcessed: boolean;
  hasManualAdjustments: boolean;
}

/**
 * Daily lesson data stored in IndexedDB
 */
export interface DailyLessonData {
  courseId: string;
  date: string;
  csvFiles: {
    morning?: StoredFile;
    afternoon?: StoredFile;
  };
  processedData?: ProcessedLessonData;
  manualAdjustments: ManualAdjustment[];
  documents: GeneratedDocuments;
  status: 'pending' | 'processing' | 'completed' | 'error';
}

/**
 * Course participant extended with course-specific data
 */
export interface CourseProcessedParticipant extends ProcessedParticipant {
  courseId: string;
  totalCourseHours: number;
  attendanceDays: string[];
  absenceDays: string[];
  manualAdjustments: ManualAdjustment[];
}

/**
 * Attendance report data
 */
export interface AttendanceReport {
  courseId: string;
  generatedAt: string;
  totalParticipants: number;
  totalLessons: number;
  averageAttendance: number;
  participantSummaries: ParticipantSummary[];
}

/**
 * Individual participant summary
 */
export interface ParticipantSummary {
  participantId: string;
  name: string;
  email: string;
  totalHours: number;
  attendedLessons: number;
  missedLessons: number;
  attendancePercentage: number;
  lastAttendance?: string;
}

// Zod Schemas for validation
export const PersonInfoSchema = z.object({
  name: z.string().min(1, 'Nome richiesto'),
  email: z.string().email('Email non valida'),
  phone: z.string().optional(),
});

export const CourseParticipantSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'Nome richiesto'),
  email: z.string().email('Email non valida'),
  enrollmentOrder: z.number().min(1),
  isActive: z.boolean(),
});

export const SessionInfoSchema = z.object({
  startTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Formato orario non valido (HH:MM)'),
  endTime: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Formato orario non valido (HH:MM)'),
  duration: z.number().min(1),
});

export const LessonScheduleSchema = z.object({
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Formato data non valido (YYYY-MM-DD)'),
  sessions: z.object({
    morning: SessionInfoSchema.optional(),
    afternoon: SessionInfoSchema.optional(),
  }),
  lessonType: z.string(),
  subject: z.string().optional(),
});

export const CourseSettingsSchema = z.object({
  minimumAttendancePercentage: z.number().min(0).max(100),
  allowManualAdjustments: z.boolean(),
  autoGenerateDocuments: z.boolean(),
  emailNotifications: z.boolean(),
  backupFrequency: z.string(),
});

export const CourseDataSchema = z.object({
  courseId: z.string(),
  courseInfo: z.object({
    name: z.string().min(1, 'Nome corso richiesto'),
    startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Formato data non valido'),
    endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Formato data non valido'),
    instructor: PersonInfoSchema,
    coordinator: PersonInfoSchema,
  }),
  participants: z.array(CourseParticipantSchema),
  schedule: z.array(LessonScheduleSchema),
  settings: CourseSettingsSchema,
  metadata: z.object({
    createdAt: z.string(),
    updatedAt: z.string(),
    version: z.string(),
    totalLessons: z.number(),
    completedLessons: z.number(),
  }),
});

export const ManualAdjustmentSchema = z.object({
  participantId: z.string(),
  session: z.string(),
  originalHours: z.number(),
  adjustedHours: z.number(),
  reason: z.string().min(1, 'Motivo richiesto'),
  adjustedBy: z.string(),
  adjustedAt: z.string(),
});

export const DailyLessonDataSchema = z.object({
  courseId: z.string(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  csvFiles: z.object({
    morning: z.object({
      filename: z.string(),
      data: z.instanceof(ArrayBuffer),
      uploadedAt: z.string(),
      size: z.number(),
    }).optional(),
    afternoon: z.object({
      filename: z.string(),
      data: z.instanceof(ArrayBuffer),
      uploadedAt: z.string(),
      size: z.number(),
    }).optional(),
  }),
  processedData: z.any().optional(), // ProcessedLessonData
  manualAdjustments: z.array(ManualAdjustmentSchema),
  documents: z.object({
    moduloB: z.object({
      filename: z.string(),
      data: z.instanceof(ArrayBuffer),
      generatedAt: z.string(),
    }).optional(),
    absenceReport: z.object({
      filename: z.string(),
      data: z.instanceof(ArrayBuffer),
      generatedAt: z.string(),
    }).optional(),
  }),
  status: z.string(),
});

/**
 * ============================================
 * FULL COURSE CSV PARSING TYPES
 * ============================================
 */

/**
 * Raw CSV row from full course export
 */
export interface FullCourseCSVRow {
  'Argomento': string;
  'Digita': string;
  'ID': string;
  'Nome organizzatore': string;
  'E-mail organizzatore': string;
  'Ora di inizio': string;
  'Ora di fine': string;
  'Partecipanti': string;
  'Durata (minuti)': string;
  'Nome (nome originale)': string;
  'E-mail': string;
  'Ora di ingresso': string;
  'Ora di uscita': string;
  'Guest': string;
  'Risposta di esclusione di responsabilit√† per la registrazione': string;
  'In sala d\'attesa': string;
}

/**
 * Session data for a single participant connection
 */
export interface FullCourseSessionData {
  participantName: string;
  email: string;
  joinTime: Date;
  leaveTime: Date;
  duration: number;
  isGuest: boolean;
  inWaitingRoom: boolean;
  disclaimerResponse: string;
}

/**
 * All sessions for a specific day
 */
export interface FullCourseDayData {
  date: string; // YYYY-MM-DD
  zoomMeetingId: string;
  courseName: string;
  startTime: Date;
  endTime: Date;
  sessions: FullCourseSessionData[];
  participantNames: Set<string>; // unique names for this day
  participantOrder?: string[]; // optional custom order for participants in Word template
}

/**
 * Participant information with aliases
 */
export interface FullCourseParticipantInfo {
  id: string; // unique ID
  primaryName: string; // canonical name
  aliases: string[]; // all variations found
  email: string;
  isOrganizer: boolean;
  masterOrder: number; // global order for placeholders
  daysPresent: string[]; // dates where participant was present
}

/**
 * Alias suggestion from automatic detection
 */
export interface AliasSuggestion {
  participantId: string;
  mainName: string;
  suggestedAliases: string[];
  similarityScores: number[]; // 0-1 for each alias
  autoMerged: boolean;
  confidence: number; // overall confidence
}

/**
 * Mapping of aliases to primary participant
 */
export interface AliasMapping {
  participantId: string;
  primaryName: string;
  mergedNames: string[];
  mergedBy: 'auto' | 'manual';
  confidence?: number;
}

/**
 * Complete parsed data from full course CSV
 */
export interface ParsedFullCourseData {
  courseName: string;
  zoomMeetingId: string;
  organizer: {
    name: string;
    email: string;
  };
  days: FullCourseDayData[];
  allParticipants: FullCourseParticipantInfo[];
  aliasSuggestions: AliasSuggestion[];
  dateRange: {
    start: string;
    end: string;
  };
  statistics: {
    totalDays: number;
    totalParticipants: number;
    totalSessions: number;
  };
}

/**
 * Participant order for document generation
 */
export interface ParticipantOrder {
  courseId: string;
  globalOrder: string[]; // participant IDs in order
  dayOrders?: Map<string, string[]>; // per-day overrides if needed
}

/**
 * Document generation result for a single day
 */
export interface DayDocumentResult {
  date: string;
  filename: string;
  success: boolean;
  error?: string;
  documentData?: ArrayBuffer;
}

/**
 * Batch document generation result (ZIP)
 */
export interface BatchDocumentResult {
  success: boolean;
  zipFilename: string;
  zipData?: Blob;
  documents: DayDocumentResult[];
  totalGenerated: number;
  totalFailed: number;
}

/**
 * ============================================
 * BATCH CSV PROCESSING TYPES (Multiple Day-by-Day CSVs)
 * ============================================
 */

/**
 * CSV file with metadata and period detection
 */
export interface BatchCSVFile {
  file: File;
  fileName: string;
  period: 'morning' | 'afternoon' | 'unknown';
  detectedDate?: string; // YYYY-MM-DD
  participantCount?: number;
  uploadedAt: Date;
}

/**
 * Paired CSV files for a single day
 */
export interface DayCSVPair {
  date: string; // YYYY-MM-DD
  morningFile?: BatchCSVFile;
  afternoonFile?: BatchCSVFile;
  isComplete: boolean; // both morning and afternoon present
  participantCount: number;
}

/**
 * Batch processing state
 */
export interface BatchProcessingState {
  status: 'idle' | 'uploading' | 'analyzing' | 'ready' | 'processing' | 'completed' | 'error';
  uploadedFiles: BatchCSVFile[];
  dayPairs: DayCSVPair[];
  currentDay?: string;
  progress: {
    current: number;
    total: number;
  };
  error?: string;
}

/**
 * Processed day result for batch
 */
export interface BatchDayResult {
  date: string;
  success: boolean;
  lessonData?: ProcessedLessonData;
  documentGenerated: boolean;
  documentFilename?: string;
  error?: string;
  participantCount?: number;
}

/**
 * Complete batch processing result
 */
export interface CompleteBatchResult {
  success: boolean;
  totalDays: number;
  successfulDays: number;
  failedDays: number;
  dayResults: BatchDayResult[];
  zipFilename?: string;
  zipData?: Blob;
  courseName?: string;
  dateRange?: {
    start: string;
    end: string;
  };
}
